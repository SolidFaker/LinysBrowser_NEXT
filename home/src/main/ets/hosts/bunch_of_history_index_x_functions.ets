import { collections, MessageEvents, worker } from '@kit.ArkTS';
import { sandbox_open_sync } from '../utils/storage_tools';
import { bunch_of_history_index } from './bunch_of_history_index';
import { bunch_of_history_index_lite } from './bunch_of_history_index_lite';

/**
 * Divides an input into single chars (CJK) and leave words (Other) as words.
 * @param input the string to be divided
 * @returns a set of parts
 * @copyright Generated by DeepSeek on 13th May, 2025
 * */
export function divide_string(input: string): Set<string> {
  // 使用正则表达式匹配所有 CJK 字符（包括中文、日文汉字、韩文汉字等）
  const cjkRegex = /[\p{Script=Han}\p{Script=Hiragana}\p{Script=Katakana}\p{Script=Hangul}]/gu;

  // 先按分隔符切分
  const parts = input.split(/[^\p{L}\p{N}]+/u);
  const result = new Set<string>();

  for (const part of parts) {
    if (part.length === 0) {
      continue;
    }

    let currentSegment = '';

    for (const char of part) {
      // 检查是否是 CJK 字符
      if (cjkRegex.test(char)) {
        // 如果是 CJK 字符，先把之前的非 CJK 段加入结果
        if (currentSegment.length > 0) {
          result.add(currentSegment);
          currentSegment = '';
        }
        // 加入 CJK 单字
        result.add(char);
        // 重置正则表达式的 lastIndex 因为我们在循环中使用 test()
        cjkRegex.lastIndex = 0;
      } else {
        // 非 CJK 字符，累积到当前段
        currentSegment += char;
      }
    }

    // 加入最后一个累积的非 CJK 段
    // Join the last cumulated non-CJK part
    if (currentSegment.length > 0) {
      result.add(currentSegment);
    }
  }

  return result;
}

/**
 * Access the disk and returns the label-link string[][] histories for given timestamps
 * @param timestamps the timestamps of history
 * @param max max number of result
 * @returns the label-link string[][] histories, for example [["SEARCH", "bing.com"], ["CCW", "ccw.site"], ...]
 * */
export function get_history_from_disk(timestamps: number[], max?: number): string[][] {
  let result: string[][] = [];
  if (timestamps.length == 0) {
    return [];
  }
  // console.log(log_head() + 'Starting to get history.')
  let year = new Date(timestamps[0]).getUTCFullYear();
  let month = new Date(timestamps[0]).getUTCMonth() + 1;
  let last_year = year;
  let last_month = month;
  let imp = sandbox_open_sync(history_path_of_month(year, month)).split("\n");
  // console.log(imp.join("\n"));
  let temp_pointer = -1;
  for (let index = 0; index < timestamps.length; index++) {
    const stamp = timestamps[index];
    // console.log("considering stamp: " + stamp.toString())

    year = new Date(stamp).getUTCFullYear();
    month = new Date(stamp).getUTCMonth() + 1;

    // Check if need to change file
    if (last_year != year || last_month != month) {
      imp = sandbox_open_sync(history_path_of_month(year, month)).split("\n");

      if (imp.length % 3 > 0) {
        console.error("[ERROR][Meow][bunch_of_history_index] Import history Error: not 3*n length. Raw string: \n" +
          imp)
        return [];
      }
      last_year = year;
      last_month = month;
      temp_pointer = -1;
    }

    while (true) {
      temp_pointer += 3;
      if (parseInt(imp[temp_pointer]) > stamp) {
        // This history doesn't exist.
        // Maybe is deleted?
        // console.log(parseInt(imp[temp_pointer]).toString());
        // console.log(stamp.toString());
        console.error("[Meow][bunch_of_history_index] History missing!");
        temp_pointer -= 3;
        break;
      } else if (temp_pointer >= imp.length) {
        console.log(timestamps.toString());
        console.log(imp.join("\n"));
        console.error("[Meow][bunch_of_history_index] Rushed over end?");
        break;
      } else if (parseInt(imp[temp_pointer]) == stamp) {
        // Found
        result.push([imp[temp_pointer-2], imp[temp_pointer-1]]);
        if (max) {
          if (result.length >= max) {
            // Meets requirement of max results;
            // console.log("[Meow][bunch_of_history_index][get_history] Met max results! Quitting in advance.")
            return result;
          }
        }
        break;
      }
    }
  }

  // console.log(log_head() + "get_history result: " + result.toString());
  return result;
}

/**
 * Calls a worker thread to load built index from disk.
 * @param load_type "normal" or "reindex".
 * */
export function history_index_load_from_disk_worker(load_type: string) {
  let history_index_saving = AppStorage.get('history_index_saving') as boolean | undefined;
  let history_index_loading = AppStorage.get('history_index_loading') as boolean | undefined;
  let reindexing = AppStorage.get('reindexing_history') as boolean | undefined;

  if (history_index_saving == true) {
    console.log(bunch_of_history_index.log_head() +
      " A history_index_saving task is ongoing! Interrupted this history_index_load_from_disk_worker.")
    return;
  }
  if (history_index_loading == true) {
    console.log(bunch_of_history_index.log_head() +
      " Another history_index_loading task is ongoing! Interrupted this history_index_load_from_disk_worker.")
    return;
  }
  if (reindexing == true && load_type != 'reindex') {
    console.log(bunch_of_history_index.log_head() +
      " A reindexing task is ongoing! Interrupted this history_index_load_from_disk_worker.")
    return;
  }

  AppStorage.set('history_index_loading', true);

  let workerInstance = new worker.ThreadWorker("home/ets/workers/History_index_loader.ets");
  workerInstance.postMessage(getContext().filesDir);

  console.log(bunch_of_history_index.log_head() + " Index loader worker CREATED!");

  workerInstance.onmessage = (e: MessageEvents): void => {
    if (typeof e.data == "string") {
      // Coming back with progress
      let data: string = e.data;
      AppStorage.set('history_index_loading_progress', data);
    } else {
      // Coming back with the whole set
      let result: collections.Array<collections.Map<string, collections.Array<number>>> = e.data;
      bunch_of_history_index.index_map = result[0];
      bunch_of_history_index_lite.index_map = result[1];

      // Set info for month_host (bunch_of_history_index_lite)
      const current_year: number = new Date().getUTCFullYear();
      const current_month: number = new Date().getUTCMonth() + 1;
      bunch_of_history_index_lite.this_year = current_year;
      bunch_of_history_index_lite.this_month = current_month;

      // STOP
      workerInstance.terminate();
      console.log(bunch_of_history_index.log_head() + " Got load result. Whole Map size: " + bunch_of_history_index.index_map.size.toString() + ".");
      console.log(bunch_of_history_index_lite.log_head() + " Got load result. Month Map size: " + bunch_of_history_index_lite.index_map.size.toString() + ".");
    }
  }
  workerInstance.onexit = (() => {
    console.log(bunch_of_history_index.log_head() + " Index loader worker TERMINATED!");

    // Set status
    if (load_type == 'reindex') {
      // Set status if this is part of reindexing
      console.log(bunch_of_history_index.log_head() + ' Index loader finished!');
      AppStorage.set('reindexing_history', false);
    }
    AppStorage.set('history_index_loading', false);
  })
}

/**
 * Calls a worker thread to save built index to disk.
 * @param map the map to be saved.
 * @param file_name the name of stored file, like 'index_2024_04_00_00_00_00_000'
 * */
export function history_index_save_to_disk_worker(map: collections.Map<string, collections.Array<number>>, file_name: string, clear: boolean) {
  let history_index_saving = AppStorage.get('history_index_saving') as boolean | undefined;
  let history_index_loading = AppStorage.get('history_index_loading') as boolean | undefined;
  let reindexing = AppStorage.get('reindexing_history') as boolean | undefined;

  if (history_index_saving == true) {
    console.log(bunch_of_history_index.log_head() + " Another history_index_saving task is ongoing! Interrupted this history_index_save_to_disk_worker.")
    return;
  }
  if (history_index_loading == true) {
    console.log(bunch_of_history_index.log_head() + " A history_index_loading task is ongoing! Interrupted this history_index_save_to_disk_worker.")
    return;
  }
  if (reindexing == true) {
    console.log(bunch_of_history_index.log_head() + " A reindexing task is ongoing! Interrupted this history_index_save_to_disk_worker.")
    return;
  }

  AppStorage.set('history_index_saving', true);

  // Get this month params
  let workerInstance = new worker.ThreadWorker("home/ets/workers/History_index_saver.ets");
  workerInstance.postMessage('filesDir:' + getContext().filesDir);
  // workerInstance.postMessage('file_name:' + 'index.txt');
  workerInstance.postMessage('file_name:' + file_name);
  // workerInstance.postMessageWithSharedSendable(bunch_of_history_index.index_map);
  workerInstance.postMessage('clear:' + clear ? 'true' : 'false');
  // workerInstance.postMessageWithSharedSendable(bunch_of_history_index.index_map);
  workerInstance.postMessageWithSharedSendable(map);
  console.log(bunch_of_history_index.log_head() + " Index saver worker CREATED!");

  workerInstance.onmessage = (e: MessageEvents): void => {
    let data: string = e.data;
    // console.info("main thread data is  " + data);
    if (data == "done") {
      workerInstance.terminate();
      // Set status
      AppStorage.set('history_index_saving', false);
    } else {
      // Coming back with progress
      AppStorage.set('history_index_saving_progress', data);
    }
  }
  workerInstance.onexit = (() => {
    console.log(bunch_of_history_index.log_head() + " Index saver worker TERMINATED!");
    // AppStorage.set('history_index_saving_progress', "...");
  })
}

/**
 * Calls a worker thread to rebuild index for all history and saves (overwrites) the index file onto disk.
 *
 * This could avoid blocking the main thread.
 *
 * Adapted from https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-worker
 * */
export function history_index_full_rebuild_worker() {
  let history_index_saving = AppStorage.get('history_index_saving') as boolean | undefined;
  let history_index_loading = AppStorage.get('history_index_loading') as boolean | undefined;
  let reindexing = AppStorage.get('reindexing_history') as boolean | undefined;

  if (history_index_saving == true) {
    console.log(bunch_of_history_index.log_head() +
      " A history_index_saving task is ongoing! Interrupted this history_index_full_rebuild_worker.")
    return;
  }
  if (history_index_loading == true) {
    console.log(bunch_of_history_index.log_head() +
      " A history_index_loading task is ongoing! Interrupted this history_index_full_rebuild_worker.")
    return;
  }
  if (reindexing == true) {
    console.log(bunch_of_history_index.log_head() +
      " Another reindexing task is ongoing! Interrupted this history_index_full_rebuild_worker.")
    return;
  }

  AppStorage.set('reindexing_history', true);

  let workerInstance = new worker.ThreadWorker("home/ets/workers/History_indexer.ets");
  workerInstance.postMessage(getContext().filesDir);
  console.log(bunch_of_history_index.log_head() + " Index worker CREATED!");

  workerInstance.onmessage = (e: MessageEvents): void => {
    let message: string = e.data;
    if (message == 'done') {
      // FINISH
      workerInstance.terminate();

      // Read from disk
      console.log("[Meow][bunch_of_history_index] Calling loader worker.");
      history_index_load_from_disk_worker('reindex');
    } else {
      // Coming back with progress
      let data: string = e.data;
      AppStorage.set('reindexing_history_progress', data);
    }
  }
  workerInstance.onexit = (() => {
    console.log(bunch_of_history_index.log_head() + " Index worker TERMINATED!");
    // AppStorage.set('reindexing_history_progress', "...");
  })
}

/**
 * Constructs the file path of history records in which history in [year, month] should be.
 * @param year A number, the year, like 2024.
 * @param month A number, the month, like 12.
 * @returns A string, 'history/history_year_month.txt'
 * */
export function history_path_of_month(year: number, month: number) {
  return 'history/' + history_file_name_of_month(year, month);
}

/**
 * Constructs the file name of history records in which history in [year, month] should be.
 * @param year A number, the year, like 2024.
 * @param month A number, the month, like 12.
 * @returns A string, 'history_YYYY_MM.txt'
 * */
export function history_file_name_of_month(year: number, month: number) {
  let month_unified = month.toString();
  if (month_unified.length == 1) {
    month_unified = '0' + month_unified;
  }
  return 'history_' + year.toString() + "_" + month_unified + '.txt';
}

/**
 * Constructs the file path of history index data in which history in [year, month] should be.
 * @param year A number, the year, like 2024.
 * @param month A number, the month, like 12.
 * @returns A string, 'history-index/index_year_month_00_00_00_00_000.txt'
 * */
export function index_path_of_month(year: number, month: number) {
  return 'history-index/' + index_file_name_of_month(year, month);
}

/**
 * Constructs the file name of history index data in which history in [year, month] should be.
 * @param year A number, the year, like 2024.
 * @param month A number, the month, like 12.
 * @returns A string, 'index_year_month_00_00_00_00_000.txt'
 * */
export function index_file_name_of_month(year: number, month: number) {
  let month_unified = month.toString();
  if (month_unified.length == 1) {
    month_unified = '0' + month_unified;
  }
  return 'index_' + year.toString() + "_" + month_unified + '_00_00_00_00_000.txt';
}